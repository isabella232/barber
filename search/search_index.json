{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Barber\ud83d\udc88 \u00b6 A type safe Kotlin JVM library for building up localized, fillable, themed documents using Mustache templating. Press \u00b6 Meet Barber\ud83d\udc88: the best way to manage your Mustache Why? \u00b6 An application will often have hundreds of user viewable strings to power UI, notifications, emails, and other text based user interactions. This leads to many questions about the how to achieve the desired functionality of these user viewable strings: These strings may want to be personalizable! Thus the string would now have to be a template that can render with a data blob unique to each user to produce a personalized string. How can we check that the fillable openings in templates have corresponding values in the data blob? How can templates and data blobs be validated at compile time to protect against runtime exceptions or user visible bugs? What if we want to pass around not just a single template string, but a collection of template strings for more complex documents? How could we support emails that have a subject, body, recipient, primary button\u2026? What about different languages? Could the same unique data blob be used to support templates in different languages? What about time or money that differ between countries that even share the same language (ie. 12 vs 24 hour time)? How could that formatting localization be provided? To answer the above questions, we built Barber\ud83d\udc88. A type safe Kotlin JVM library for building up localized, fillable, themed documents using Mustache templating. Getting Started \u00b6 To get started using Barber, skim below to understand the different elements used to safely render your localized, fillable, themed documents using Mustache templating. Releases \u00b6 Our change log has release history. API is subject to change. implementation ( \"app.cash.barber:barber:0.3.3\" ) Snapshot builds are available . DocumentData \u00b6 DocumentData is the data that is used to render a template. In Barber, this is defined as a data class making it easy to use in Kotlin. // Define DocumentData data class RecipientReceipt ( val sender : String , val amount : String , val cancelUrl : String , val deposit_expected_at : Instant ) : DocumentData To render a template, for example \"{{sender}} sent you {{amount}}\" , an instance of the above DocumentData could be passed in to fill the fillable openings in the template. Document \u00b6 The final fields of the output, rendered document. For simple documents, this may be a single field. // Define Document data class TransactionalSmsDocument ( val sms_body : String ) : Document For more complex documents that may be used in further processing, there may be multiple fields, which can be nullable. data class TransactionalEmailDocument ( val subject : String , val headline : String , val short_description : String , val primary_button : String? , val primary_button_url : String? , val secondary_button : String? , val secondary_button_url : String? ) : Document DocumentTemplate \u00b6 A DocumentTemplate is the glue that connects the DocumentData to the Document. It contains: - fields: - keys fulfill all the non-nullable keys of the Document targets - values are Mustache templates that are rendered with the passed in source DocumentData - source: DocumentData that can support all fillable templates in fields - targets: Document s that the DocumentTemplate can render to - locale: Locale for the language of the fields templates val recipientReceiptSmsDocumentTemplateEN_US = DocumentTemplate ( fields = mapOf ( \"sms_body\" to \"{{sender}} sent you {{amount}}\" ), source = RecipientReceipt :: class , targets = setOf ( TransactionalSmsDocument :: class ), locale = Locale . EN_US ) Barber \u00b6 A Barber is typed to the DocumentData -> Document relationship that it knows how to render. Amy knows how to cut blonde hair into a Fu Manchu mustache. Joe knows how to trim brown hair into a soul patch mustache. // A Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument val recipientReceiptSms : Barber < RecipientReceipt , TransactionalSmsDocument > Barbershop \u00b6 A Barbershop contains all possible Barbers based on the installed DocumentData , DocumentTemplate , and Document s. Each Barber knows how to handle a different combination of DocumentData -> Document . You can call barbershop.getBarber<RecipientReceipt, TransactionalSmsDocument>() to get the Barber that can handle rendering a RecipientReceipt into a TransactionalSmsDocument . // Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument val recipientReceiptSms = barbershop . getBarber < RecipientReceipt , TransactionalSmsDocument > () You want a soul patch and have brown hair, get Joe! You want a Fu Manchu and have blonde hair, get Amy! You can also get a Map of all Barbers using barbershop.getAllBarbers() . // Get all Barbers val allBarbers : Map < BarberKey , Barber < DocumentData , Document >> = barbershop . getAllBarbers () Note: BarberKey is a data class that let\u2019s us lookup by both DocumentData and Document . BarbershopBuilder \u00b6 A Java style Builder that installs all of the above Barber elements and returns a pre-compiled and validated Barbershop. Install DocumentData and DocumentTemplate pairs with .installDocumentTemplate<RecipientReceipt>(recipientReceiptSmsDocumentTemplateEN_US) . Install Document with .installDocument<TransactionalSmsDocument>() Optionally set a custom LocaleResolver with .setLocaleResolver(MapleSyrupOrFirstLocaleResolver()) Optionally set a default BarberFieldEncoding for non-annotated Document fields with .setDefaultBarberFieldEncoding(STRING_PLAINTEXT) Optionally configure warning validation strictness with .setWarningsAsErrors() Return the finished Barbershop with .build() as the final method call on BarbershopBuilder. val barbershop = BarbershopBuilder () . installDocumentTemplate < RecipientReceipt > ( recipientReceiptSmsDocumentTemplateEN_US ) . installDocument < TransactionalSmsDocument > () . build () Barber .render(data: DocumentData, locale: Locale) \u00b6 To render the final Document , a Barber requires a DocumentData , used to fill the DocumentTemplate , and an output Locale. First, the Barber uses a LocaleResolver to find the best Locale match from installed DocumentTemplate s. Then, using the Locale resolved DocumentTemplate , Barber renders the fields of DocumentTemplate using the passed in DocumentData . Returned is the requested Document rendered with the personalized values of DocumentData in the closest match to the requested Locale. // Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument val recipientReceiptSms = barbershop . getBarber < RecipientReceipt , TransactionalSmsDocument > () // Create the RecipientReceipt instance that holds the personalized data val sandy50Receipt = RecipientReceipt ( sender = \"Sandy Winchester\" , amount = \" $ 50 \" , cancelUrl = \"https://cash.app/cancel/123\" , deposit_expected_at = Instant . parse ( \"2019-05-21T16:02:00.00Z\" ) ) // Render the final document using the personalized DocumentData instance and the output Locale val renderedSms = recipientReceiptSms . render ( sandy50Receipt , EN_US ) @BarberField, BarberFieldEncoding, and HTML Character Escaping \u00b6 The @BarberField annotation can be used on Document class val fields to declare that the field should be rendered and treated according to a specific BarberFieldEncoding . BarberFieldEncoding can be for now STRING_HTML or STRING_PLAINTEXT . By default, all fields are treated as STRING_HTML and have common HTML escaping of characters for safety. When a field is annotated as STRING_PLAINTEXT , characters will not be escaped. data class EncodingTestDocument ( val no_annotation_field : String , @BarberField () val default_field : String , @BarberField ( encoding = BarberFieldEncoding . STRING_HTML ) val html_field : String , @BarberField ( encoding = BarberFieldEncoding . STRING_PLAINTEXT ) val plaintext_field : String ) : Document // Rendered with all fields set to `You purchased 100 shares of McDonald's.` EncodingTestDocument ( no_annotation_field = \"You purchased 100 shares of McDonald&#39;s.\" , default_field = \"You purchased 100 shares of McDonald&#39;s.\" , html_field = \"You purchased 100 shares of McDonald&#39;s.\" , // Note: no character escaping on the plaintext field plaintext_field = \"You purchased 100 shares of McDonald's.\" ) Locale \u00b6 Barber supports installation and resolution of multiple Locales for each DocumentTemplate . All Locale versions of a DocumentTemplate will be installed with the BarbershopBuilder. The desired output Locale is then provided at render time and the best available option is resolved. // Define DocumentTemplate in English val recipientReceiptSmsDocumentTemplateEN_US = DocumentTemplate ( fields = mapOf ( \"sms_body\" to \"{{sender}} sent you {{amount}}\" ), source = RecipientReceipt :: class , targets = setOf ( TransactionalSmsDocument :: class ), locale = Locale . EN_US ) // Define DocumentTemplate in Canadian English val recipientReceiptSmsDocumentTemplateEN_CA = DocumentTemplate ( fields = mapOf ( \"sms_body\" to \"{{sender}} sent you {{amount}}, eh!\" ), // ... same as EN_US locale = Locale . EN_CA ) // Define DocumentTemplate in Spanish val recipientReceiptSmsDocumentTemplateES_US = DocumentTemplate ( fields = mapOf ( \"sms_body\" to \"{{sender}} te envi\u00f3 {{amount}}\" ), // ... same as EN_US locale = Locale . ES_US ) // Use above elements to build a Barbershop val barbershop = BarbershopBuilder () . installDocumentTemplate < RecipientReceipt > ( recipientReceiptSmsDocumentTemplateEN_US ) . installDocumentTemplate < RecipientReceipt > ( recipientReceiptSmsDocumentTemplateEN_CA ) . installDocumentTemplate < RecipientReceipt > ( recipientReceiptSmsDocumentTemplateES_US ) . installDocument < TransactionalSmsDocument > () . build () // Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument val recipientReceiptSms = barbershop . getBarber < RecipientReceipt , TransactionalSmsDocument > () // Render in each Locale val smsEN_US = recipientReceiptSms . render ( sandy50Receipt , EN_US ) // = Sandy Winchester sent you $50 val smsEN_CA = recipientReceiptSms . render ( sandy50Receipt , EN_CA ) // = Sandy Winchester sent you $50, eh? val smsES_US = recipientReceiptSms . render ( sandy50Receipt , ES_US ) // = Sandy Winchester te envio $50 LocaleResolver \u00b6 Determining based on a Locale passed in at render which installed Locale to render is done by a LocaleResolver. It is a simple interface that looks like this: abstract class LocaleResolver { /** * @return a [Locale] from the given [options] * @param [options] must be valid keys for a Locale keyed Map */ fun resolve ( locale : Locale , options : Set < Locale > ): Locale } Barber comes with a very simple MatchOrFirstLocaleResolver that attempts to resolve the requested Locale exactly, and otherwise chooses the first installed Locale. For more complex resolution algorithms, you can set your own custom LocaleResolver when building your Barbershop. val barbershop = BarbershopBuilder () // ... . setLocaleResolver ( MapleSyrupOrFirstLocaleResolver ) // Always tries to resolve EN_CA . build () Version Compatibility & Resolution \u00b6 Barber supports installation of multiple versions of the same template. When Barber is used in a service that stores in a database versioned templates, the following capabilities drastically improve the safety, reliability, and functionality of rendering versioned templates. For example, Barber can handle variable additions, subtractions, and changes between versions. For example, if a template has a new variable added, the corresponding DocumentData class will also have a new field. // git diff of the new version of the DocumentData data class RecipientReceipt ( val sender : String , val amount : String , + val recipient : String , ) : DocumentData Assuming a microservice environment where old clients could exist sending the old DocumentData missing the new field, Barber does the right thing and falls back to the newest, compatible template to render. Compatibility in this case refers to ensuring that the signature (variables and types) of the DocumentData provided can fulfill the chosen template. By default , Barber chooses the newest compatible version, or throws an exception if a version is explicitly provided that does not exist or is incompatible. For more complex resolution algorithms, you can set your own custom VersionResolver when building your Barbershop. val barbershop = BarbershopBuilder () // ... . setVersionResolver ( SpecifiedOrNewestCompatibleVersionResolver ) // Always returns newest compatible version, ignores explicitly provided version . build () Integration with Guice \u00b6 If you use Guice, creating a module that automatically binds all possible typed Barber instances is simple. See the code example below. package com.your.service.package import com.google.inject.AbstractModule import com.google.inject.Key import com.google.inject.util.Types import app.cash.barber.Barber import app.cash.barber.Barbershop import app.cash.barber.models.BarberKey import app.cash.barber.models.Document import app.cash.barber.models.DocumentData /** * Binds all the barbers so they may be injected directly like so: * * ``` * @Inject var barber: Barber<RecipientReceipt, TransactionalSmsDocument> * ``` */ class BarberModule ( private val barbershop : Barbershop ) : AbstractModule () { override fun configure () { barbershop . getAllBarbers (). forEach { ( barberKey , barber ) -> bind ( barberKey . asGuiceKey ()). toInstance ( barber ) } } private fun BarberKey . asGuiceKey (): Key < Barber < DocumentData , Document >> { val barberType = Types . newParameterizedType ( Barber :: class . java , documentData . java , document . java ) @Suppress ( \"UNCHECKED_CAST\" ) // We know this cast is safe dynamically. return Key . get ( barberType ) as Key < Barber < DocumentData , Document >> } } Coming Soon \u00b6 FieldStemming \u00b6 Automatically replace Money, DateTime, and Instant types with BarberMoney, BarberDateTime, and BarberInstant that let templates call out localized formatted output of each type. Example BarberInstant(Instant(2019-05-15T15:23:11), EN_US) = mapOf( \"date\" to \"May 15, 2019\", \"time\" to \"3:23 pm\", \"casual\" to \"tomorrow at 3pm\" ) BarberMoney(Money(50_00), EN_US) = mapOf( \"full\" to \"$50.00\" \"casual\" to \"$50\" ) License \u00b6 Copyright 2019 Square, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#barber","text":"A type safe Kotlin JVM library for building up localized, fillable, themed documents using Mustache templating.","title":"Barber\ud83d\udc88"},{"location":"#press","text":"Meet Barber\ud83d\udc88: the best way to manage your Mustache","title":"Press"},{"location":"#why","text":"An application will often have hundreds of user viewable strings to power UI, notifications, emails, and other text based user interactions. This leads to many questions about the how to achieve the desired functionality of these user viewable strings: These strings may want to be personalizable! Thus the string would now have to be a template that can render with a data blob unique to each user to produce a personalized string. How can we check that the fillable openings in templates have corresponding values in the data blob? How can templates and data blobs be validated at compile time to protect against runtime exceptions or user visible bugs? What if we want to pass around not just a single template string, but a collection of template strings for more complex documents? How could we support emails that have a subject, body, recipient, primary button\u2026? What about different languages? Could the same unique data blob be used to support templates in different languages? What about time or money that differ between countries that even share the same language (ie. 12 vs 24 hour time)? How could that formatting localization be provided? To answer the above questions, we built Barber\ud83d\udc88. A type safe Kotlin JVM library for building up localized, fillable, themed documents using Mustache templating.","title":"Why?"},{"location":"#getting-started","text":"To get started using Barber, skim below to understand the different elements used to safely render your localized, fillable, themed documents using Mustache templating.","title":"Getting Started"},{"location":"#releases","text":"Our change log has release history. API is subject to change. implementation ( \"app.cash.barber:barber:0.3.3\" ) Snapshot builds are available .","title":"Releases"},{"location":"#documentdata","text":"DocumentData is the data that is used to render a template. In Barber, this is defined as a data class making it easy to use in Kotlin. // Define DocumentData data class RecipientReceipt ( val sender : String , val amount : String , val cancelUrl : String , val deposit_expected_at : Instant ) : DocumentData To render a template, for example \"{{sender}} sent you {{amount}}\" , an instance of the above DocumentData could be passed in to fill the fillable openings in the template.","title":"DocumentData"},{"location":"#document","text":"The final fields of the output, rendered document. For simple documents, this may be a single field. // Define Document data class TransactionalSmsDocument ( val sms_body : String ) : Document For more complex documents that may be used in further processing, there may be multiple fields, which can be nullable. data class TransactionalEmailDocument ( val subject : String , val headline : String , val short_description : String , val primary_button : String? , val primary_button_url : String? , val secondary_button : String? , val secondary_button_url : String? ) : Document","title":"Document"},{"location":"#documenttemplate","text":"A DocumentTemplate is the glue that connects the DocumentData to the Document. It contains: - fields: - keys fulfill all the non-nullable keys of the Document targets - values are Mustache templates that are rendered with the passed in source DocumentData - source: DocumentData that can support all fillable templates in fields - targets: Document s that the DocumentTemplate can render to - locale: Locale for the language of the fields templates val recipientReceiptSmsDocumentTemplateEN_US = DocumentTemplate ( fields = mapOf ( \"sms_body\" to \"{{sender}} sent you {{amount}}\" ), source = RecipientReceipt :: class , targets = setOf ( TransactionalSmsDocument :: class ), locale = Locale . EN_US )","title":"DocumentTemplate"},{"location":"#barber_1","text":"A Barber is typed to the DocumentData -> Document relationship that it knows how to render. Amy knows how to cut blonde hair into a Fu Manchu mustache. Joe knows how to trim brown hair into a soul patch mustache. // A Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument val recipientReceiptSms : Barber < RecipientReceipt , TransactionalSmsDocument >","title":"Barber"},{"location":"#barbershop","text":"A Barbershop contains all possible Barbers based on the installed DocumentData , DocumentTemplate , and Document s. Each Barber knows how to handle a different combination of DocumentData -> Document . You can call barbershop.getBarber<RecipientReceipt, TransactionalSmsDocument>() to get the Barber that can handle rendering a RecipientReceipt into a TransactionalSmsDocument . // Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument val recipientReceiptSms = barbershop . getBarber < RecipientReceipt , TransactionalSmsDocument > () You want a soul patch and have brown hair, get Joe! You want a Fu Manchu and have blonde hair, get Amy! You can also get a Map of all Barbers using barbershop.getAllBarbers() . // Get all Barbers val allBarbers : Map < BarberKey , Barber < DocumentData , Document >> = barbershop . getAllBarbers () Note: BarberKey is a data class that let\u2019s us lookup by both DocumentData and Document .","title":"Barbershop"},{"location":"#barbershopbuilder","text":"A Java style Builder that installs all of the above Barber elements and returns a pre-compiled and validated Barbershop. Install DocumentData and DocumentTemplate pairs with .installDocumentTemplate<RecipientReceipt>(recipientReceiptSmsDocumentTemplateEN_US) . Install Document with .installDocument<TransactionalSmsDocument>() Optionally set a custom LocaleResolver with .setLocaleResolver(MapleSyrupOrFirstLocaleResolver()) Optionally set a default BarberFieldEncoding for non-annotated Document fields with .setDefaultBarberFieldEncoding(STRING_PLAINTEXT) Optionally configure warning validation strictness with .setWarningsAsErrors() Return the finished Barbershop with .build() as the final method call on BarbershopBuilder. val barbershop = BarbershopBuilder () . installDocumentTemplate < RecipientReceipt > ( recipientReceiptSmsDocumentTemplateEN_US ) . installDocument < TransactionalSmsDocument > () . build ()","title":"BarbershopBuilder"},{"location":"#barberrenderdata-documentdata-locale-locale","text":"To render the final Document , a Barber requires a DocumentData , used to fill the DocumentTemplate , and an output Locale. First, the Barber uses a LocaleResolver to find the best Locale match from installed DocumentTemplate s. Then, using the Locale resolved DocumentTemplate , Barber renders the fields of DocumentTemplate using the passed in DocumentData . Returned is the requested Document rendered with the personalized values of DocumentData in the closest match to the requested Locale. // Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument val recipientReceiptSms = barbershop . getBarber < RecipientReceipt , TransactionalSmsDocument > () // Create the RecipientReceipt instance that holds the personalized data val sandy50Receipt = RecipientReceipt ( sender = \"Sandy Winchester\" , amount = \" $ 50 \" , cancelUrl = \"https://cash.app/cancel/123\" , deposit_expected_at = Instant . parse ( \"2019-05-21T16:02:00.00Z\" ) ) // Render the final document using the personalized DocumentData instance and the output Locale val renderedSms = recipientReceiptSms . render ( sandy50Receipt , EN_US )","title":"Barber.render(data: DocumentData, locale: Locale)"},{"location":"#barberfield-barberfieldencoding-and-html-character-escaping","text":"The @BarberField annotation can be used on Document class val fields to declare that the field should be rendered and treated according to a specific BarberFieldEncoding . BarberFieldEncoding can be for now STRING_HTML or STRING_PLAINTEXT . By default, all fields are treated as STRING_HTML and have common HTML escaping of characters for safety. When a field is annotated as STRING_PLAINTEXT , characters will not be escaped. data class EncodingTestDocument ( val no_annotation_field : String , @BarberField () val default_field : String , @BarberField ( encoding = BarberFieldEncoding . STRING_HTML ) val html_field : String , @BarberField ( encoding = BarberFieldEncoding . STRING_PLAINTEXT ) val plaintext_field : String ) : Document // Rendered with all fields set to `You purchased 100 shares of McDonald's.` EncodingTestDocument ( no_annotation_field = \"You purchased 100 shares of McDonald&#39;s.\" , default_field = \"You purchased 100 shares of McDonald&#39;s.\" , html_field = \"You purchased 100 shares of McDonald&#39;s.\" , // Note: no character escaping on the plaintext field plaintext_field = \"You purchased 100 shares of McDonald's.\" )","title":"@BarberField, BarberFieldEncoding, and HTML Character Escaping"},{"location":"#locale","text":"Barber supports installation and resolution of multiple Locales for each DocumentTemplate . All Locale versions of a DocumentTemplate will be installed with the BarbershopBuilder. The desired output Locale is then provided at render time and the best available option is resolved. // Define DocumentTemplate in English val recipientReceiptSmsDocumentTemplateEN_US = DocumentTemplate ( fields = mapOf ( \"sms_body\" to \"{{sender}} sent you {{amount}}\" ), source = RecipientReceipt :: class , targets = setOf ( TransactionalSmsDocument :: class ), locale = Locale . EN_US ) // Define DocumentTemplate in Canadian English val recipientReceiptSmsDocumentTemplateEN_CA = DocumentTemplate ( fields = mapOf ( \"sms_body\" to \"{{sender}} sent you {{amount}}, eh!\" ), // ... same as EN_US locale = Locale . EN_CA ) // Define DocumentTemplate in Spanish val recipientReceiptSmsDocumentTemplateES_US = DocumentTemplate ( fields = mapOf ( \"sms_body\" to \"{{sender}} te envi\u00f3 {{amount}}\" ), // ... same as EN_US locale = Locale . ES_US ) // Use above elements to build a Barbershop val barbershop = BarbershopBuilder () . installDocumentTemplate < RecipientReceipt > ( recipientReceiptSmsDocumentTemplateEN_US ) . installDocumentTemplate < RecipientReceipt > ( recipientReceiptSmsDocumentTemplateEN_CA ) . installDocumentTemplate < RecipientReceipt > ( recipientReceiptSmsDocumentTemplateES_US ) . installDocument < TransactionalSmsDocument > () . build () // Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument val recipientReceiptSms = barbershop . getBarber < RecipientReceipt , TransactionalSmsDocument > () // Render in each Locale val smsEN_US = recipientReceiptSms . render ( sandy50Receipt , EN_US ) // = Sandy Winchester sent you $50 val smsEN_CA = recipientReceiptSms . render ( sandy50Receipt , EN_CA ) // = Sandy Winchester sent you $50, eh? val smsES_US = recipientReceiptSms . render ( sandy50Receipt , ES_US ) // = Sandy Winchester te envio $50","title":"Locale"},{"location":"#localeresolver","text":"Determining based on a Locale passed in at render which installed Locale to render is done by a LocaleResolver. It is a simple interface that looks like this: abstract class LocaleResolver { /** * @return a [Locale] from the given [options] * @param [options] must be valid keys for a Locale keyed Map */ fun resolve ( locale : Locale , options : Set < Locale > ): Locale } Barber comes with a very simple MatchOrFirstLocaleResolver that attempts to resolve the requested Locale exactly, and otherwise chooses the first installed Locale. For more complex resolution algorithms, you can set your own custom LocaleResolver when building your Barbershop. val barbershop = BarbershopBuilder () // ... . setLocaleResolver ( MapleSyrupOrFirstLocaleResolver ) // Always tries to resolve EN_CA . build ()","title":"LocaleResolver"},{"location":"#version-compatibility-resolution","text":"Barber supports installation of multiple versions of the same template. When Barber is used in a service that stores in a database versioned templates, the following capabilities drastically improve the safety, reliability, and functionality of rendering versioned templates. For example, Barber can handle variable additions, subtractions, and changes between versions. For example, if a template has a new variable added, the corresponding DocumentData class will also have a new field. // git diff of the new version of the DocumentData data class RecipientReceipt ( val sender : String , val amount : String , + val recipient : String , ) : DocumentData Assuming a microservice environment where old clients could exist sending the old DocumentData missing the new field, Barber does the right thing and falls back to the newest, compatible template to render. Compatibility in this case refers to ensuring that the signature (variables and types) of the DocumentData provided can fulfill the chosen template. By default , Barber chooses the newest compatible version, or throws an exception if a version is explicitly provided that does not exist or is incompatible. For more complex resolution algorithms, you can set your own custom VersionResolver when building your Barbershop. val barbershop = BarbershopBuilder () // ... . setVersionResolver ( SpecifiedOrNewestCompatibleVersionResolver ) // Always returns newest compatible version, ignores explicitly provided version . build ()","title":"Version Compatibility &amp; Resolution"},{"location":"#integration-with-guice","text":"If you use Guice, creating a module that automatically binds all possible typed Barber instances is simple. See the code example below. package com.your.service.package import com.google.inject.AbstractModule import com.google.inject.Key import com.google.inject.util.Types import app.cash.barber.Barber import app.cash.barber.Barbershop import app.cash.barber.models.BarberKey import app.cash.barber.models.Document import app.cash.barber.models.DocumentData /** * Binds all the barbers so they may be injected directly like so: * * ``` * @Inject var barber: Barber<RecipientReceipt, TransactionalSmsDocument> * ``` */ class BarberModule ( private val barbershop : Barbershop ) : AbstractModule () { override fun configure () { barbershop . getAllBarbers (). forEach { ( barberKey , barber ) -> bind ( barberKey . asGuiceKey ()). toInstance ( barber ) } } private fun BarberKey . asGuiceKey (): Key < Barber < DocumentData , Document >> { val barberType = Types . newParameterizedType ( Barber :: class . java , documentData . java , document . java ) @Suppress ( \"UNCHECKED_CAST\" ) // We know this cast is safe dynamically. return Key . get ( barberType ) as Key < Barber < DocumentData , Document >> } }","title":"Integration with Guice"},{"location":"#coming-soon","text":"","title":"Coming Soon"},{"location":"#fieldstemming","text":"Automatically replace Money, DateTime, and Instant types with BarberMoney, BarberDateTime, and BarberInstant that let templates call out localized formatted output of each type. Example BarberInstant(Instant(2019-05-15T15:23:11), EN_US) = mapOf( \"date\" to \"May 15, 2019\", \"time\" to \"3:23 pm\", \"casual\" to \"tomorrow at 3pm\" ) BarberMoney(Money(50_00), EN_US) = mapOf( \"full\" to \"$50.00\" \"casual\" to \"$50\" )","title":"FieldStemming"},{"location":"#license","text":"Copyright 2019 Square, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Change Log \u00b6 Version 0.3.2 \u00b6 2020-10-21 Include Protos in Jar Version 0.3.1 \u00b6 2020-10-21 Render null DocumentData field as empty string, not as \u201cnull\u201d Version 0.3.0 \u00b6 2020-10-21 Default to String when Proto DocumentData has a null field with ambiguous type Version 0.2.0 \u00b6 2020-10-21 New support for dynamic document data and templates using Protos Version 0.1.0 \u00b6 2019-07-16 Initial release.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-032","text":"2020-10-21 Include Protos in Jar","title":"Version 0.3.2"},{"location":"changelog/#version-031","text":"2020-10-21 Render null DocumentData field as empty string, not as \u201cnull\u201d","title":"Version 0.3.1"},{"location":"changelog/#version-030","text":"2020-10-21 Default to String when Proto DocumentData has a null field with ambiguous type","title":"Version 0.3.0"},{"location":"changelog/#version-020","text":"2020-10-21 New support for dynamic document data and templates using Protos","title":"Version 0.2.0"},{"location":"changelog/#version-010","text":"2019-07-16 Initial release.","title":"Version 0.1.0"},{"location":"contributing/","text":"Contributing \u00b6 If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"contributing/#contributing","text":"If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"releasing-manual/","text":"Manual Releasing Steps \u00b6 These should generally not be needed but are kept here for posterity. The CI auto-releasing in Github Actions should be sufficient, and is documented in the Releasing doc. Prerequisite: Sonatype (Maven Central) Account \u00b6 Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for app.cash projects. Prerequisite: GPG Keys \u00b6 Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@cash.app> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX Prerequisite: Gradle Properties \u00b6 Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jwilson/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg Cutting a Release \u00b6 Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"app.cash.barber:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"app.cash.barber:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` ./gradlew clean uploadArchives Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a barber-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Manual Releasing"},{"location":"releasing-manual/#manual-releasing-steps","text":"These should generally not be needed but are kept here for posterity. The CI auto-releasing in Github Actions should be sufficient, and is documented in the Releasing doc.","title":"Manual Releasing Steps"},{"location":"releasing-manual/#prerequisite-sonatype-maven-central-account","text":"Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for app.cash projects.","title":"Prerequisite: Sonatype (Maven Central) Account"},{"location":"releasing-manual/#prerequisite-gpg-keys","text":"Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@cash.app> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX","title":"Prerequisite: GPG Keys"},{"location":"releasing-manual/#prerequisite-gradle-properties","text":"Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jwilson/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg","title":"Prerequisite: Gradle Properties"},{"location":"releasing-manual/#cutting-a-release","text":"Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"app.cash.barber:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"app.cash.barber:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` ./gradlew clean uploadArchives Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a barber-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Cutting a Release"},{"location":"releasing/","text":"Releasing \u00b6 Update CHANGELOG.md . Set versions: export RELEASE_VERSION=A.B.C export NEXT_VERSION=A.B.D-SNAPSHOT Update documentation and Gradle properties with RELEASE_VERSION sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"app.cash.barber:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"app.cash.barber:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` Tag the release and push to GitHub. Merge PR. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a barber-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" git push && git push --tags Wait until the \u201cPublish a release\u201d action completes, then visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Prepare for the next release and push to GitHub. Merge PR. sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push Draft a new release of A.B.C to trigger the \u201cPublish the mkdocs to gh-pages\u201d action. Troubleshooting \u00b6 If the github action fails, drop the artifacts from Sonatype and re run the job. You might need to delete the plugin off the JetBrains plugin portal first if the ubuntu job which publishes it already succeeded.","title":"Releasing"},{"location":"releasing/#releasing","text":"Update CHANGELOG.md . Set versions: export RELEASE_VERSION=A.B.C export NEXT_VERSION=A.B.D-SNAPSHOT Update documentation and Gradle properties with RELEASE_VERSION sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"app.cash.barber:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"app.cash.barber:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` Tag the release and push to GitHub. Merge PR. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a barber-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" git push && git push --tags Wait until the \u201cPublish a release\u201d action completes, then visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Prepare for the next release and push to GitHub. Merge PR. sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push Draft a new release of A.B.C to trigger the \u201cPublish the mkdocs to gh-pages\u201d action.","title":"Releasing"},{"location":"releasing/#troubleshooting","text":"If the github action fails, drop the artifacts from Sonatype and re run the job. You might need to delete the plugin off the JetBrains plugin portal first if the ubuntu job which publishes it already succeeded.","title":"Troubleshooting"}]}